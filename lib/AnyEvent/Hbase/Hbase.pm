#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use AnyEvent::Hbase::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Hbase::Hbase_enableTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_enableTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_enableTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_enableTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_enableTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_disableTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_disableTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_disableTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_disableTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_disableTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_isTableEnabled_args;
use base qw(Class::Accessor);
Hbase::Hbase_isTableEnabled_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_isTableEnabled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_isTableEnabled_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_isTableEnabled_result;
use base qw(Class::Accessor);
Hbase::Hbase_isTableEnabled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_isTableEnabled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_isTableEnabled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_compact_args;
use base qw(Class::Accessor);
Hbase::Hbase_compact_args->mk_accessors( qw( tableNameOrRegionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableNameOrRegionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableNameOrRegionName}) {
      $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_compact_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableNameOrRegionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_compact_args');
  if (defined $self->{tableNameOrRegionName}) {
    $xfer += $output->writeFieldBegin('tableNameOrRegionName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableNameOrRegionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_compact_result;
use base qw(Class::Accessor);
Hbase::Hbase_compact_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_compact_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_compact_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_majorCompact_args;
use base qw(Class::Accessor);
Hbase::Hbase_majorCompact_args->mk_accessors( qw( tableNameOrRegionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableNameOrRegionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableNameOrRegionName}) {
      $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_majorCompact_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableNameOrRegionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_majorCompact_args');
  if (defined $self->{tableNameOrRegionName}) {
    $xfer += $output->writeFieldBegin('tableNameOrRegionName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableNameOrRegionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_majorCompact_result;
use base qw(Class::Accessor);
Hbase::Hbase_majorCompact_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_majorCompact_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_majorCompact_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableNames_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableNames_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableNames_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableNames_result;
use base qw(Class::Accessor);
Hbase::Hbase_getTableNames_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableNames_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size30 = 0;
          $self->{success} = [];
          my $_etype33 = 0;
          $xfer += $input->readListBegin(\$_etype33, \$_size30);
          for (my $_i34 = 0; $_i34 < $_size30; ++$_i34)
          {
            my $elem35 = undef;
            $xfer += $input->readString(\$elem35);
            push(@{$self->{success}},$elem35);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableNames_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter36 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter36);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getColumnDescriptors_args;
use base qw(Class::Accessor);
Hbase::Hbase_getColumnDescriptors_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getColumnDescriptors_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getColumnDescriptors_result;
use base qw(Class::Accessor);
Hbase::Hbase_getColumnDescriptors_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getColumnDescriptors_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size37 = 0;
          $self->{success} = {};
          my $_ktype38 = 0;
          my $_vtype39 = 0;
          $xfer += $input->readMapBegin(\$_ktype38, \$_vtype39, \$_size37);
          for (my $_i41 = 0; $_i41 < $_size37; ++$_i41)
          {
            my $key42 = '';
            my $val43 = new Hbase::ColumnDescriptor();
            $xfer += $input->readString(\$key42);
            $val43 = new Hbase::ColumnDescriptor();
            $xfer += $val43->read($input);
            $self->{success}->{$key42} = $val43;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter44,$viter45) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter44);
          $xfer += ${viter45}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableRegions_args;
use base qw(Class::Accessor);
Hbase::Hbase_getTableRegions_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableRegions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableRegions_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableRegions_result;
use base qw(Class::Accessor);
Hbase::Hbase_getTableRegions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableRegions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size46 = 0;
          $self->{success} = [];
          my $_etype49 = 0;
          $xfer += $input->readListBegin(\$_etype49, \$_size46);
          for (my $_i50 = 0; $_i50 < $_size46; ++$_i50)
          {
            my $elem51 = undef;
            $elem51 = new Hbase::TRegionInfo();
            $xfer += $elem51->read($input);
            push(@{$self->{success}},$elem51);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableRegions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter52 (@{$self->{success}}) 
        {
          $xfer += ${iter52}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_createTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_createTable_args->mk_accessors( qw( tableName columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size53 = 0;
          $self->{columnFamilies} = [];
          my $_etype56 = 0;
          $xfer += $input->readListBegin(\$_etype56, \$_size53);
          for (my $_i57 = 0; $_i57 < $_size53; ++$_i57)
          {
            my $elem58 = undef;
            $elem58 = new Hbase::ColumnDescriptor();
            $xfer += $elem58->read($input);
            push(@{$self->{columnFamilies}},$elem58);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_createTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columnFamilies}}));
      {
        foreach my $iter59 (@{$self->{columnFamilies}}) 
        {
          $xfer += ${iter59}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_createTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  $self->{exist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
    if (defined $vals->{exist}) {
      $self->{exist} = $vals->{exist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{exist} = new Hbase::AlreadyExists();
        $xfer += $self->{exist}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_createTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exist}) {
    $xfer += $output->writeFieldBegin('exist', TType::STRUCT, 3);
    $xfer += $self->{exist}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_get_args;
use base qw(Class::Accessor);
Hbase::Hbase_get_args->mk_accessors( qw( tableName row column attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size60 = 0;
          $self->{attributes} = {};
          my $_ktype61 = 0;
          my $_vtype62 = 0;
          $xfer += $input->readMapBegin(\$_ktype61, \$_vtype62, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $key65 = '';
            my $val66 = '';
            $xfer += $input->readString(\$key65);
            $xfer += $input->readString(\$val66);
            $self->{attributes}->{$key65} = $val66;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_get_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter67,$viter68) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter67);
          $xfer += $output->writeString($viter68);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_get_result;
use base qw(Class::Accessor);
Hbase::Hbase_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size69 = 0;
          $self->{success} = [];
          my $_etype72 = 0;
          $xfer += $input->readListBegin(\$_etype72, \$_size69);
          for (my $_i73 = 0; $_i73 < $_size69; ++$_i73)
          {
            my $elem74 = undef;
            $elem74 = new Hbase::TCell();
            $xfer += $elem74->read($input);
            push(@{$self->{success}},$elem74);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter75 (@{$self->{success}}) 
        {
          $xfer += ${iter75}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVer_args;
use base qw(Class::Accessor);
Hbase::Hbase_getVer_args->mk_accessors( qw( tableName row column numVersions attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{numVersions} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{numVersions}) {
      $self->{numVersions} = $vals->{numVersions};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size76 = 0;
          $self->{attributes} = {};
          my $_ktype77 = 0;
          my $_vtype78 = 0;
          $xfer += $input->readMapBegin(\$_ktype77, \$_vtype78, \$_size76);
          for (my $_i80 = 0; $_i80 < $_size76; ++$_i80)
          {
            my $key81 = '';
            my $val82 = '';
            $xfer += $input->readString(\$key81);
            $xfer += $input->readString(\$val82);
            $self->{attributes}->{$key81} = $val82;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVer_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numVersions}) {
    $xfer += $output->writeFieldBegin('numVersions', TType::I32, 4);
    $xfer += $output->writeI32($self->{numVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter83,$viter84) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter83);
          $xfer += $output->writeString($viter84);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVer_result;
use base qw(Class::Accessor);
Hbase::Hbase_getVer_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size85 = 0;
          $self->{success} = [];
          my $_etype88 = 0;
          $xfer += $input->readListBegin(\$_etype88, \$_size85);
          for (my $_i89 = 0; $_i89 < $_size85; ++$_i89)
          {
            my $elem90 = undef;
            $elem90 = new Hbase::TCell();
            $xfer += $elem90->read($input);
            push(@{$self->{success}},$elem90);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVer_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter91 (@{$self->{success}}) 
        {
          $xfer += ${iter91}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVerTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getVerTs_args->mk_accessors( qw( tableName row column timestamp numVersions attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{timestamp} = undef;
  $self->{numVersions} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{numVersions}) {
      $self->{numVersions} = $vals->{numVersions};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVerTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size92 = 0;
          $self->{attributes} = {};
          my $_ktype93 = 0;
          my $_vtype94 = 0;
          $xfer += $input->readMapBegin(\$_ktype93, \$_vtype94, \$_size92);
          for (my $_i96 = 0; $_i96 < $_size92; ++$_i96)
          {
            my $key97 = '';
            my $val98 = '';
            $xfer += $input->readString(\$key97);
            $xfer += $input->readString(\$val98);
            $self->{attributes}->{$key97} = $val98;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVerTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numVersions}) {
    $xfer += $output->writeFieldBegin('numVersions', TType::I32, 5);
    $xfer += $output->writeI32($self->{numVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter99,$viter100) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter99);
          $xfer += $output->writeString($viter100);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVerTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getVerTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVerTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size101 = 0;
          $self->{success} = [];
          my $_etype104 = 0;
          $xfer += $input->readListBegin(\$_etype104, \$_size101);
          for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
          {
            my $elem106 = undef;
            $elem106 = new Hbase::TCell();
            $xfer += $elem106->read($input);
            push(@{$self->{success}},$elem106);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVerTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter107 (@{$self->{success}}) 
        {
          $xfer += ${iter107}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRow_args->mk_accessors( qw( tableName row attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size108 = 0;
          $self->{attributes} = {};
          my $_ktype109 = 0;
          my $_vtype110 = 0;
          $xfer += $input->readMapBegin(\$_ktype109, \$_vtype110, \$_size108);
          for (my $_i112 = 0; $_i112 < $_size108; ++$_i112)
          {
            my $key113 = '';
            my $val114 = '';
            $xfer += $input->readString(\$key113);
            $xfer += $input->readString(\$val114);
            $self->{attributes}->{$key113} = $val114;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter115,$viter116) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter115);
          $xfer += $output->writeString($viter116);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size117 = 0;
          $self->{success} = [];
          my $_etype120 = 0;
          $xfer += $input->readListBegin(\$_etype120, \$_size117);
          for (my $_i121 = 0; $_i121 < $_size117; ++$_i121)
          {
            my $elem122 = undef;
            $elem122 = new Hbase::TRowResult();
            $xfer += $elem122->read($input);
            push(@{$self->{success}},$elem122);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter123 (@{$self->{success}}) 
        {
          $xfer += ${iter123}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumns_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumns_args->mk_accessors( qw( tableName row columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size124 = 0;
          $self->{columns} = [];
          my $_etype127 = 0;
          $xfer += $input->readListBegin(\$_etype127, \$_size124);
          for (my $_i128 = 0; $_i128 < $_size124; ++$_i128)
          {
            my $elem129 = undef;
            $xfer += $input->readString(\$elem129);
            push(@{$self->{columns}},$elem129);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size130 = 0;
          $self->{attributes} = {};
          my $_ktype131 = 0;
          my $_vtype132 = 0;
          $xfer += $input->readMapBegin(\$_ktype131, \$_vtype132, \$_size130);
          for (my $_i134 = 0; $_i134 < $_size130; ++$_i134)
          {
            my $key135 = '';
            my $val136 = '';
            $xfer += $input->readString(\$key135);
            $xfer += $input->readString(\$val136);
            $self->{attributes}->{$key135} = $val136;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter137 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter137);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter138,$viter139) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter138);
          $xfer += $output->writeString($viter139);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumns_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size140 = 0;
          $self->{success} = [];
          my $_etype143 = 0;
          $xfer += $input->readListBegin(\$_etype143, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $elem145 = undef;
            $elem145 = new Hbase::TRowResult();
            $xfer += $elem145->read($input);
            push(@{$self->{success}},$elem145);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter146 (@{$self->{success}}) 
        {
          $xfer += ${iter146}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size147 = 0;
          $self->{attributes} = {};
          my $_ktype148 = 0;
          my $_vtype149 = 0;
          $xfer += $input->readMapBegin(\$_ktype148, \$_vtype149, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $key152 = '';
            my $val153 = '';
            $xfer += $input->readString(\$key152);
            $xfer += $input->readString(\$val153);
            $self->{attributes}->{$key152} = $val153;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter154,$viter155) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter154);
          $xfer += $output->writeString($viter155);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size156 = 0;
          $self->{success} = [];
          my $_etype159 = 0;
          $xfer += $input->readListBegin(\$_etype159, \$_size156);
          for (my $_i160 = 0; $_i160 < $_size156; ++$_i160)
          {
            my $elem161 = undef;
            $elem161 = new Hbase::TRowResult();
            $xfer += $elem161->read($input);
            push(@{$self->{success}},$elem161);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter162 (@{$self->{success}}) 
        {
          $xfer += ${iter162}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumnsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumnsTs_args->mk_accessors( qw( tableName row columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumnsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size163 = 0;
          $self->{columns} = [];
          my $_etype166 = 0;
          $xfer += $input->readListBegin(\$_etype166, \$_size163);
          for (my $_i167 = 0; $_i167 < $_size163; ++$_i167)
          {
            my $elem168 = undef;
            $xfer += $input->readString(\$elem168);
            push(@{$self->{columns}},$elem168);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size169 = 0;
          $self->{attributes} = {};
          my $_ktype170 = 0;
          my $_vtype171 = 0;
          $xfer += $input->readMapBegin(\$_ktype170, \$_vtype171, \$_size169);
          for (my $_i173 = 0; $_i173 < $_size169; ++$_i173)
          {
            my $key174 = '';
            my $val175 = '';
            $xfer += $input->readString(\$key174);
            $xfer += $input->readString(\$val175);
            $self->{attributes}->{$key174} = $val175;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter176 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter176);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter177,$viter178) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter177);
          $xfer += $output->writeString($viter178);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumnsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumnsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumnsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size179 = 0;
          $self->{success} = [];
          my $_etype182 = 0;
          $xfer += $input->readListBegin(\$_etype182, \$_size179);
          for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
          {
            my $elem184 = undef;
            $elem184 = new Hbase::TRowResult();
            $xfer += $elem184->read($input);
            push(@{$self->{success}},$elem184);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter185 (@{$self->{success}}) 
        {
          $xfer += ${iter185}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRows_args->mk_accessors( qw( tableName rows attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size186 = 0;
          $self->{rows} = [];
          my $_etype189 = 0;
          $xfer += $input->readListBegin(\$_etype189, \$_size186);
          for (my $_i190 = 0; $_i190 < $_size186; ++$_i190)
          {
            my $elem191 = undef;
            $xfer += $input->readString(\$elem191);
            push(@{$self->{rows}},$elem191);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size192 = 0;
          $self->{attributes} = {};
          my $_ktype193 = 0;
          my $_vtype194 = 0;
          $xfer += $input->readMapBegin(\$_ktype193, \$_vtype194, \$_size192);
          for (my $_i196 = 0; $_i196 < $_size192; ++$_i196)
          {
            my $key197 = '';
            my $val198 = '';
            $xfer += $input->readString(\$key197);
            $xfer += $input->readString(\$val198);
            $self->{attributes}->{$key197} = $val198;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRows_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter199 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter199);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter200,$viter201) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter200);
          $xfer += $output->writeString($viter201);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRows_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size202 = 0;
          $self->{success} = [];
          my $_etype205 = 0;
          $xfer += $input->readListBegin(\$_etype205, \$_size202);
          for (my $_i206 = 0; $_i206 < $_size202; ++$_i206)
          {
            my $elem207 = undef;
            $elem207 = new Hbase::TRowResult();
            $xfer += $elem207->read($input);
            push(@{$self->{success}},$elem207);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRows_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter208 (@{$self->{success}}) 
        {
          $xfer += ${iter208}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumns_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumns_args->mk_accessors( qw( tableName rows columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size209 = 0;
          $self->{rows} = [];
          my $_etype212 = 0;
          $xfer += $input->readListBegin(\$_etype212, \$_size209);
          for (my $_i213 = 0; $_i213 < $_size209; ++$_i213)
          {
            my $elem214 = undef;
            $xfer += $input->readString(\$elem214);
            push(@{$self->{rows}},$elem214);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size215 = 0;
          $self->{columns} = [];
          my $_etype218 = 0;
          $xfer += $input->readListBegin(\$_etype218, \$_size215);
          for (my $_i219 = 0; $_i219 < $_size215; ++$_i219)
          {
            my $elem220 = undef;
            $xfer += $input->readString(\$elem220);
            push(@{$self->{columns}},$elem220);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size221 = 0;
          $self->{attributes} = {};
          my $_ktype222 = 0;
          my $_vtype223 = 0;
          $xfer += $input->readMapBegin(\$_ktype222, \$_vtype223, \$_size221);
          for (my $_i225 = 0; $_i225 < $_size221; ++$_i225)
          {
            my $key226 = '';
            my $val227 = '';
            $xfer += $input->readString(\$key226);
            $xfer += $input->readString(\$val227);
            $self->{attributes}->{$key226} = $val227;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter228 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter228);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter229 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter229);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter230,$viter231) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter230);
          $xfer += $output->writeString($viter231);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumns_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size232 = 0;
          $self->{success} = [];
          my $_etype235 = 0;
          $xfer += $input->readListBegin(\$_etype235, \$_size232);
          for (my $_i236 = 0; $_i236 < $_size232; ++$_i236)
          {
            my $elem237 = undef;
            $elem237 = new Hbase::TRowResult();
            $xfer += $elem237->read($input);
            push(@{$self->{success}},$elem237);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter238 (@{$self->{success}}) 
        {
          $xfer += ${iter238}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsTs_args->mk_accessors( qw( tableName rows timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size239 = 0;
          $self->{rows} = [];
          my $_etype242 = 0;
          $xfer += $input->readListBegin(\$_etype242, \$_size239);
          for (my $_i243 = 0; $_i243 < $_size239; ++$_i243)
          {
            my $elem244 = undef;
            $xfer += $input->readString(\$elem244);
            push(@{$self->{rows}},$elem244);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size245 = 0;
          $self->{attributes} = {};
          my $_ktype246 = 0;
          my $_vtype247 = 0;
          $xfer += $input->readMapBegin(\$_ktype246, \$_vtype247, \$_size245);
          for (my $_i249 = 0; $_i249 < $_size245; ++$_i249)
          {
            my $key250 = '';
            my $val251 = '';
            $xfer += $input->readString(\$key250);
            $xfer += $input->readString(\$val251);
            $self->{attributes}->{$key250} = $val251;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter252 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter252);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter253,$viter254) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter253);
          $xfer += $output->writeString($viter254);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size255 = 0;
          $self->{success} = [];
          my $_etype258 = 0;
          $xfer += $input->readListBegin(\$_etype258, \$_size255);
          for (my $_i259 = 0; $_i259 < $_size255; ++$_i259)
          {
            my $elem260 = undef;
            $elem260 = new Hbase::TRowResult();
            $xfer += $elem260->read($input);
            push(@{$self->{success}},$elem260);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter261 (@{$self->{success}}) 
        {
          $xfer += ${iter261}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumnsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumnsTs_args->mk_accessors( qw( tableName rows columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumnsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size262 = 0;
          $self->{rows} = [];
          my $_etype265 = 0;
          $xfer += $input->readListBegin(\$_etype265, \$_size262);
          for (my $_i266 = 0; $_i266 < $_size262; ++$_i266)
          {
            my $elem267 = undef;
            $xfer += $input->readString(\$elem267);
            push(@{$self->{rows}},$elem267);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size268 = 0;
          $self->{columns} = [];
          my $_etype271 = 0;
          $xfer += $input->readListBegin(\$_etype271, \$_size268);
          for (my $_i272 = 0; $_i272 < $_size268; ++$_i272)
          {
            my $elem273 = undef;
            $xfer += $input->readString(\$elem273);
            push(@{$self->{columns}},$elem273);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size274 = 0;
          $self->{attributes} = {};
          my $_ktype275 = 0;
          my $_vtype276 = 0;
          $xfer += $input->readMapBegin(\$_ktype275, \$_vtype276, \$_size274);
          for (my $_i278 = 0; $_i278 < $_size274; ++$_i278)
          {
            my $key279 = '';
            my $val280 = '';
            $xfer += $input->readString(\$key279);
            $xfer += $input->readString(\$val280);
            $self->{attributes}->{$key279} = $val280;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter281 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter281);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter282 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter282);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter283,$viter284) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter283);
          $xfer += $output->writeString($viter284);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumnsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumnsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumnsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size285 = 0;
          $self->{success} = [];
          my $_etype288 = 0;
          $xfer += $input->readListBegin(\$_etype288, \$_size285);
          for (my $_i289 = 0; $_i289 < $_size285; ++$_i289)
          {
            my $elem290 = undef;
            $elem290 = new Hbase::TRowResult();
            $xfer += $elem290->read($input);
            push(@{$self->{success}},$elem290);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter291 (@{$self->{success}}) 
        {
          $xfer += ${iter291}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRow_args->mk_accessors( qw( tableName row mutations attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{mutations} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size292 = 0;
          $self->{mutations} = [];
          my $_etype295 = 0;
          $xfer += $input->readListBegin(\$_etype295, \$_size292);
          for (my $_i296 = 0; $_i296 < $_size292; ++$_i296)
          {
            my $elem297 = undef;
            $elem297 = new Hbase::Mutation();
            $xfer += $elem297->read($input);
            push(@{$self->{mutations}},$elem297);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size298 = 0;
          $self->{attributes} = {};
          my $_ktype299 = 0;
          my $_vtype300 = 0;
          $xfer += $input->readMapBegin(\$_ktype299, \$_vtype300, \$_size298);
          for (my $_i302 = 0; $_i302 < $_size298; ++$_i302)
          {
            my $key303 = '';
            my $val304 = '';
            $xfer += $input->readString(\$key303);
            $xfer += $input->readString(\$val304);
            $self->{attributes}->{$key303} = $val304;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter305 (@{$self->{mutations}}) 
        {
          $xfer += ${iter305}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter306,$viter307) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter306);
          $xfer += $output->writeString($viter307);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRow_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRow_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowTs_args->mk_accessors( qw( tableName row mutations timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{mutations} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size308 = 0;
          $self->{mutations} = [];
          my $_etype311 = 0;
          $xfer += $input->readListBegin(\$_etype311, \$_size308);
          for (my $_i312 = 0; $_i312 < $_size308; ++$_i312)
          {
            my $elem313 = undef;
            $elem313 = new Hbase::Mutation();
            $xfer += $elem313->read($input);
            push(@{$self->{mutations}},$elem313);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size314 = 0;
          $self->{attributes} = {};
          my $_ktype315 = 0;
          my $_vtype316 = 0;
          $xfer += $input->readMapBegin(\$_ktype315, \$_vtype316, \$_size314);
          for (my $_i318 = 0; $_i318 < $_size314; ++$_i318)
          {
            my $key319 = '';
            my $val320 = '';
            $xfer += $input->readString(\$key319);
            $xfer += $input->readString(\$val320);
            $self->{attributes}->{$key319} = $val320;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter321 (@{$self->{mutations}}) 
        {
          $xfer += ${iter321}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter322,$viter323) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter322);
          $xfer += $output->writeString($viter323);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRows_args->mk_accessors( qw( tableName rowBatches attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rowBatches} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rowBatches}) {
      $self->{rowBatches} = $vals->{rowBatches};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size324 = 0;
          $self->{rowBatches} = [];
          my $_etype327 = 0;
          $xfer += $input->readListBegin(\$_etype327, \$_size324);
          for (my $_i328 = 0; $_i328 < $_size324; ++$_i328)
          {
            my $elem329 = undef;
            $elem329 = new Hbase::BatchMutation();
            $xfer += $elem329->read($input);
            push(@{$self->{rowBatches}},$elem329);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size330 = 0;
          $self->{attributes} = {};
          my $_ktype331 = 0;
          my $_vtype332 = 0;
          $xfer += $input->readMapBegin(\$_ktype331, \$_vtype332, \$_size330);
          for (my $_i334 = 0; $_i334 < $_size330; ++$_i334)
          {
            my $key335 = '';
            my $val336 = '';
            $xfer += $input->readString(\$key335);
            $xfer += $input->readString(\$val336);
            $self->{attributes}->{$key335} = $val336;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRows_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowBatches}) {
    $xfer += $output->writeFieldBegin('rowBatches', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rowBatches}}));
      {
        foreach my $iter337 (@{$self->{rowBatches}}) 
        {
          $xfer += ${iter337}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter338,$viter339) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter338);
          $xfer += $output->writeString($viter339);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRows_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRows_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowsTs_args->mk_accessors( qw( tableName rowBatches timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rowBatches} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rowBatches}) {
      $self->{rowBatches} = $vals->{rowBatches};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size340 = 0;
          $self->{rowBatches} = [];
          my $_etype343 = 0;
          $xfer += $input->readListBegin(\$_etype343, \$_size340);
          for (my $_i344 = 0; $_i344 < $_size340; ++$_i344)
          {
            my $elem345 = undef;
            $elem345 = new Hbase::BatchMutation();
            $xfer += $elem345->read($input);
            push(@{$self->{rowBatches}},$elem345);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size346 = 0;
          $self->{attributes} = {};
          my $_ktype347 = 0;
          my $_vtype348 = 0;
          $xfer += $input->readMapBegin(\$_ktype347, \$_vtype348, \$_size346);
          for (my $_i350 = 0; $_i350 < $_size346; ++$_i350)
          {
            my $key351 = '';
            my $val352 = '';
            $xfer += $input->readString(\$key351);
            $xfer += $input->readString(\$val352);
            $self->{attributes}->{$key351} = $val352;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowBatches}) {
    $xfer += $output->writeFieldBegin('rowBatches', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rowBatches}}));
      {
        foreach my $iter353 (@{$self->{rowBatches}}) 
        {
          $xfer += ${iter353}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter354,$viter355) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter354);
          $xfer += $output->writeString($viter355);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowsTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_atomicIncrement_args;
use base qw(Class::Accessor);
Hbase::Hbase_atomicIncrement_args->mk_accessors( qw( tableName row column value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_atomicIncrement_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_atomicIncrement_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I64, 4);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_atomicIncrement_result;
use base qw(Class::Accessor);
Hbase::Hbase_atomicIncrement_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_atomicIncrement_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_atomicIncrement_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAll_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAll_args->mk_accessors( qw( tableName row column attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAll_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size356 = 0;
          $self->{attributes} = {};
          my $_ktype357 = 0;
          my $_vtype358 = 0;
          $xfer += $input->readMapBegin(\$_ktype357, \$_vtype358, \$_size356);
          for (my $_i360 = 0; $_i360 < $_size356; ++$_i360)
          {
            my $key361 = '';
            my $val362 = '';
            $xfer += $input->readString(\$key361);
            $xfer += $input->readString(\$val362);
            $self->{attributes}->{$key361} = $val362;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAll_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter363,$viter364) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter363);
          $xfer += $output->writeString($viter364);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAll_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAll_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAll_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAll_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllTs_args->mk_accessors( qw( tableName row column timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size365 = 0;
          $self->{attributes} = {};
          my $_ktype366 = 0;
          my $_vtype367 = 0;
          $xfer += $input->readMapBegin(\$_ktype366, \$_vtype367, \$_size365);
          for (my $_i369 = 0; $_i369 < $_size365; ++$_i369)
          {
            my $key370 = '';
            my $val371 = '';
            $xfer += $input->readString(\$key370);
            $xfer += $input->readString(\$val371);
            $self->{attributes}->{$key370} = $val371;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter372,$viter373) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter372);
          $xfer += $output->writeString($viter373);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRow_args->mk_accessors( qw( tableName row attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size374 = 0;
          $self->{attributes} = {};
          my $_ktype375 = 0;
          my $_vtype376 = 0;
          $xfer += $input->readMapBegin(\$_ktype375, \$_vtype376, \$_size374);
          for (my $_i378 = 0; $_i378 < $_size374; ++$_i378)
          {
            my $key379 = '';
            my $val380 = '';
            $xfer += $input->readString(\$key379);
            $xfer += $input->readString(\$val380);
            $self->{attributes}->{$key379} = $val380;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter381,$viter382) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter381);
          $xfer += $output->writeString($viter382);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRow_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRow_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_increment_args;
use base qw(Class::Accessor);
Hbase::Hbase_increment_args->mk_accessors( qw( increment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{increment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{increment}) {
      $self->{increment} = $vals->{increment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_increment_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{increment} = new Hbase::TIncrement();
        $xfer += $self->{increment}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_increment_args');
  if (defined $self->{increment}) {
    $xfer += $output->writeFieldBegin('increment', TType::STRUCT, 1);
    $xfer += $self->{increment}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_increment_result;
use base qw(Class::Accessor);
Hbase::Hbase_increment_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_increment_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_increment_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_incrementRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_incrementRows_args->mk_accessors( qw( increments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{increments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{increments}) {
      $self->{increments} = $vals->{increments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_incrementRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size383 = 0;
          $self->{increments} = [];
          my $_etype386 = 0;
          $xfer += $input->readListBegin(\$_etype386, \$_size383);
          for (my $_i387 = 0; $_i387 < $_size383; ++$_i387)
          {
            my $elem388 = undef;
            $elem388 = new Hbase::TIncrement();
            $xfer += $elem388->read($input);
            push(@{$self->{increments}},$elem388);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_incrementRows_args');
  if (defined $self->{increments}) {
    $xfer += $output->writeFieldBegin('increments', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{increments}}));
      {
        foreach my $iter389 (@{$self->{increments}}) 
        {
          $xfer += ${iter389}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_incrementRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_incrementRows_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_incrementRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_incrementRows_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size390 = 0;
          $self->{attributes} = {};
          my $_ktype391 = 0;
          my $_vtype392 = 0;
          $xfer += $input->readMapBegin(\$_ktype391, \$_vtype392, \$_size390);
          for (my $_i394 = 0; $_i394 < $_size390; ++$_i394)
          {
            my $key395 = '';
            my $val396 = '';
            $xfer += $input->readString(\$key395);
            $xfer += $input->readString(\$val396);
            $self->{attributes}->{$key395} = $val396;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter397,$viter398) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter397);
          $xfer += $output->writeString($viter398);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRowTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithScan_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithScan_args->mk_accessors( qw( tableName scan attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{scan} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{scan}) {
      $self->{scan} = $vals->{scan};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithScan_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan} = new Hbase::TScan();
        $xfer += $self->{scan}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size399 = 0;
          $self->{attributes} = {};
          my $_ktype400 = 0;
          my $_vtype401 = 0;
          $xfer += $input->readMapBegin(\$_ktype400, \$_vtype401, \$_size399);
          for (my $_i403 = 0; $_i403 < $_size399; ++$_i403)
          {
            my $key404 = '';
            my $val405 = '';
            $xfer += $input->readString(\$key404);
            $xfer += $input->readString(\$val405);
            $self->{attributes}->{$key404} = $val405;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan}) {
    $xfer += $output->writeFieldBegin('scan', TType::STRUCT, 2);
    $xfer += $self->{scan}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter406,$viter407) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter406);
          $xfer += $output->writeString($viter407);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithScan_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithScan_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithScan_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpen_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpen_args->mk_accessors( qw( tableName startRow columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpen_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size408 = 0;
          $self->{columns} = [];
          my $_etype411 = 0;
          $xfer += $input->readListBegin(\$_etype411, \$_size408);
          for (my $_i412 = 0; $_i412 < $_size408; ++$_i412)
          {
            my $elem413 = undef;
            $xfer += $input->readString(\$elem413);
            push(@{$self->{columns}},$elem413);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size414 = 0;
          $self->{attributes} = {};
          my $_ktype415 = 0;
          my $_vtype416 = 0;
          $xfer += $input->readMapBegin(\$_ktype415, \$_vtype416, \$_size414);
          for (my $_i418 = 0; $_i418 < $_size414; ++$_i418)
          {
            my $key419 = '';
            my $val420 = '';
            $xfer += $input->readString(\$key419);
            $xfer += $input->readString(\$val420);
            $self->{attributes}->{$key419} = $val420;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpen_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter421 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter421);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter422,$viter423) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter422);
          $xfer += $output->writeString($viter423);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpen_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpen_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpen_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpen_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStop_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStop_args->mk_accessors( qw( tableName startRow stopRow columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size424 = 0;
          $self->{columns} = [];
          my $_etype427 = 0;
          $xfer += $input->readListBegin(\$_etype427, \$_size424);
          for (my $_i428 = 0; $_i428 < $_size424; ++$_i428)
          {
            my $elem429 = undef;
            $xfer += $input->readString(\$elem429);
            push(@{$self->{columns}},$elem429);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size430 = 0;
          $self->{attributes} = {};
          my $_ktype431 = 0;
          my $_vtype432 = 0;
          $xfer += $input->readMapBegin(\$_ktype431, \$_vtype432, \$_size430);
          for (my $_i434 = 0; $_i434 < $_size430; ++$_i434)
          {
            my $key435 = '';
            my $val436 = '';
            $xfer += $input->readString(\$key435);
            $xfer += $input->readString(\$val436);
            $self->{attributes}->{$key435} = $val436;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter437 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter437);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter438,$viter439) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter438);
          $xfer += $output->writeString($viter439);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStop_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStop_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithPrefix_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithPrefix_args->mk_accessors( qw( tableName startAndPrefix columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startAndPrefix} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startAndPrefix}) {
      $self->{startAndPrefix} = $vals->{startAndPrefix};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithPrefix_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startAndPrefix});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size440 = 0;
          $self->{columns} = [];
          my $_etype443 = 0;
          $xfer += $input->readListBegin(\$_etype443, \$_size440);
          for (my $_i444 = 0; $_i444 < $_size440; ++$_i444)
          {
            my $elem445 = undef;
            $xfer += $input->readString(\$elem445);
            push(@{$self->{columns}},$elem445);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size446 = 0;
          $self->{attributes} = {};
          my $_ktype447 = 0;
          my $_vtype448 = 0;
          $xfer += $input->readMapBegin(\$_ktype447, \$_vtype448, \$_size446);
          for (my $_i450 = 0; $_i450 < $_size446; ++$_i450)
          {
            my $key451 = '';
            my $val452 = '';
            $xfer += $input->readString(\$key451);
            $xfer += $input->readString(\$val452);
            $self->{attributes}->{$key451} = $val452;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startAndPrefix}) {
    $xfer += $output->writeFieldBegin('startAndPrefix', TType::STRING, 2);
    $xfer += $output->writeString($self->{startAndPrefix});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter453 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter453);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter454,$viter455) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter454);
          $xfer += $output->writeString($viter455);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithPrefix_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithPrefix_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithPrefix_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenTs_args->mk_accessors( qw( tableName startRow columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size456 = 0;
          $self->{columns} = [];
          my $_etype459 = 0;
          $xfer += $input->readListBegin(\$_etype459, \$_size456);
          for (my $_i460 = 0; $_i460 < $_size456; ++$_i460)
          {
            my $elem461 = undef;
            $xfer += $input->readString(\$elem461);
            push(@{$self->{columns}},$elem461);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size462 = 0;
          $self->{attributes} = {};
          my $_ktype463 = 0;
          my $_vtype464 = 0;
          $xfer += $input->readMapBegin(\$_ktype463, \$_vtype464, \$_size462);
          for (my $_i466 = 0; $_i466 < $_size462; ++$_i466)
          {
            my $key467 = '';
            my $val468 = '';
            $xfer += $input->readString(\$key467);
            $xfer += $input->readString(\$val468);
            $self->{attributes}->{$key467} = $val468;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter469 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter469);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter470,$viter471) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter470);
          $xfer += $output->writeString($viter471);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStopTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStopTs_args->mk_accessors( qw( tableName startRow stopRow columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStopTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size472 = 0;
          $self->{columns} = [];
          my $_etype475 = 0;
          $xfer += $input->readListBegin(\$_etype475, \$_size472);
          for (my $_i476 = 0; $_i476 < $_size472; ++$_i476)
          {
            my $elem477 = undef;
            $xfer += $input->readString(\$elem477);
            push(@{$self->{columns}},$elem477);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size478 = 0;
          $self->{attributes} = {};
          my $_ktype479 = 0;
          my $_vtype480 = 0;
          $xfer += $input->readMapBegin(\$_ktype479, \$_vtype480, \$_size478);
          for (my $_i482 = 0; $_i482 < $_size478; ++$_i482)
          {
            my $key483 = '';
            my $val484 = '';
            $xfer += $input->readString(\$key483);
            $xfer += $input->readString(\$val484);
            $self->{attributes}->{$key483} = $val484;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter485 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter485);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 5);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter486,$viter487) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter486);
          $xfer += $output->writeString($viter487);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStopTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStopTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStopTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGet_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGet_args->mk_accessors( qw( id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGet_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGet_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size488 = 0;
          $self->{success} = [];
          my $_etype491 = 0;
          $xfer += $input->readListBegin(\$_etype491, \$_size488);
          for (my $_i492 = 0; $_i492 < $_size488; ++$_i492)
          {
            my $elem493 = undef;
            $elem493 = new Hbase::TRowResult();
            $xfer += $elem493->read($input);
            push(@{$self->{success}},$elem493);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter494 (@{$self->{success}}) 
        {
          $xfer += ${iter494}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGetList_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGetList_args->mk_accessors( qw( id nbRows ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{nbRows} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{nbRows}) {
      $self->{nbRows} = $vals->{nbRows};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGetList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{nbRows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGetList_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nbRows}) {
    $xfer += $output->writeFieldBegin('nbRows', TType::I32, 2);
    $xfer += $output->writeI32($self->{nbRows});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGetList_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGetList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGetList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size495 = 0;
          $self->{success} = [];
          my $_etype498 = 0;
          $xfer += $input->readListBegin(\$_etype498, \$_size495);
          for (my $_i499 = 0; $_i499 < $_size495; ++$_i499)
          {
            my $elem500 = undef;
            $elem500 = new Hbase::TRowResult();
            $xfer += $elem500->read($input);
            push(@{$self->{success}},$elem500);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGetList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter501 (@{$self->{success}}) 
        {
          $xfer += ${iter501}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerClose_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerClose_args->mk_accessors( qw( id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerClose_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerClose_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerClose_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerClose_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerClose_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerClose_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowOrBefore_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowOrBefore_args->mk_accessors( qw( tableName row family ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{family} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowOrBefore_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowOrBefore_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 3);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowOrBefore_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowOrBefore_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowOrBefore_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size502 = 0;
          $self->{success} = [];
          my $_etype505 = 0;
          $xfer += $input->readListBegin(\$_etype505, \$_size502);
          for (my $_i506 = 0; $_i506 < $_size502; ++$_i506)
          {
            my $elem507 = undef;
            $elem507 = new Hbase::TCell();
            $xfer += $elem507->read($input);
            push(@{$self->{success}},$elem507);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowOrBefore_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter508 (@{$self->{success}}) 
        {
          $xfer += ${iter508}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRegionInfo_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRegionInfo_args->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRegionInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRegionInfo_args');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRegionInfo_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRegionInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRegionInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hbase::TRegionInfo();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRegionInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::HbaseIf;

use strict;


sub enableTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub isTableEnabled{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  die 'implement interface';
}

sub majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  die 'implement interface';
}

sub getTableNames{
  my $self = shift;

  die 'implement interface';
}

sub getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub getTableRegions{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

  die 'implement interface';
}

sub deleteTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

  die 'implement interface';
}

sub deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub increment{
  my $self = shift;
  my $increment = shift;

  die 'implement interface';
}

sub incrementRows{
  my $self = shift;
  my $increments = shift;

  die 'implement interface';
}

sub deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerGet{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

  die 'implement interface';
}

sub scannerClose{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub getRowOrBefore{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $family = shift;

  die 'implement interface';
}

sub getRegionInfo{
  my $self = shift;
  my $row = shift;

  die 'implement interface';
}

package Hbase::HbaseRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub enableTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->enableTable($tableName);
}

sub disableTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->disableTable($tableName);
}

sub isTableEnabled{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->isTableEnabled($tableName);
}

sub compact{
  my ($self, $request) = @_;

  my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
  return $self->{impl}->compact($tableNameOrRegionName);
}

sub majorCompact{
  my ($self, $request) = @_;

  my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
  return $self->{impl}->majorCompact($tableNameOrRegionName);
}

sub getTableNames{
  my ($self, $request) = @_;

  return $self->{impl}->getTableNames();
}

sub getColumnDescriptors{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->getColumnDescriptors($tableName);
}

sub getTableRegions{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->getTableRegions($tableName);
}

sub createTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $columnFamilies = ($request->{'columnFamilies'}) ? $request->{'columnFamilies'} : undef;
  return $self->{impl}->createTable($tableName, $columnFamilies);
}

sub deleteTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->deleteTable($tableName);
}

sub get{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->get($tableName, $row, $column, $attributes);
}

sub getVer{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getVer($tableName, $row, $column, $numVersions, $attributes);
}

sub getVerTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
}

sub getRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRow($tableName, $row, $attributes);
}

sub getRowWithColumns{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowWithColumns($tableName, $row, $columns, $attributes);
}

sub getRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowTs($tableName, $row, $timestamp, $attributes);
}

sub getRowWithColumnsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
}

sub getRows{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRows($tableName, $rows, $attributes);
}

sub getRowsWithColumns{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsWithColumns($tableName, $rows, $columns, $attributes);
}

sub getRowsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsTs($tableName, $rows, $timestamp, $attributes);
}

sub getRowsWithColumnsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
}

sub mutateRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRow($tableName, $row, $mutations, $attributes);
}

sub mutateRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
}

sub mutateRows{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRows($tableName, $rowBatches, $attributes);
}

sub mutateRowsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
}

sub atomicIncrement{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->atomicIncrement($tableName, $row, $column, $value);
}

sub deleteAll{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAll($tableName, $row, $column, $attributes);
}

sub deleteAllTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
}

sub deleteAllRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllRow($tableName, $row, $attributes);
}

sub increment{
  my ($self, $request) = @_;

  my $increment = ($request->{'increment'}) ? $request->{'increment'} : undef;
  return $self->{impl}->increment($increment);
}

sub incrementRows{
  my ($self, $request) = @_;

  my $increments = ($request->{'increments'}) ? $request->{'increments'} : undef;
  return $self->{impl}->incrementRows($increments);
}

sub deleteAllRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllRowTs($tableName, $row, $timestamp, $attributes);
}

sub scannerOpenWithScan{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $scan = ($request->{'scan'}) ? $request->{'scan'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithScan($tableName, $scan, $attributes);
}

sub scannerOpen{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpen($tableName, $startRow, $columns, $attributes);
}

sub scannerOpenWithStop{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
}

sub scannerOpenWithPrefix{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startAndPrefix = ($request->{'startAndPrefix'}) ? $request->{'startAndPrefix'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
}

sub scannerOpenTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
}

sub scannerOpenWithStopTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
}

sub scannerGet{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  return $self->{impl}->scannerGet($id);
}

sub scannerGetList{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  my $nbRows = ($request->{'nbRows'}) ? $request->{'nbRows'} : undef;
  return $self->{impl}->scannerGetList($id, $nbRows);
}

sub scannerClose{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  return $self->{impl}->scannerClose($id);
}

sub getRowOrBefore{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $family = ($request->{'family'}) ? $request->{'family'} : undef;
  return $self->{impl}->getRowOrBefore($tableName, $row, $family);
}

sub getRegionInfo{
  my ($self, $request) = @_;

  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->getRegionInfo($row);
}

package Hbase::HbaseClient;


use base qw(Hbase::HbaseIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub enableTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_enableTable($tableName);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('enableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_enableTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_enableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_disableTable($tableName);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('disableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_disableTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_disableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub isTableEnabled{
  my $self = shift;
  my $tableName = shift;

    $self->send_isTableEnabled($tableName);
  return $self->recv_isTableEnabled();
}

sub send_isTableEnabled{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('isTableEnabled', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_isTableEnabled_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isTableEnabled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_isTableEnabled_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "isTableEnabled failed: unknown result";
}
sub compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

    $self->send_compact($tableNameOrRegionName);
  $self->recv_compact();
}

sub send_compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  $self->{output}->writeMessageBegin('compact', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_compact_args();
  $args->{tableNameOrRegionName} = $tableNameOrRegionName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_compact{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_compact_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

    $self->send_majorCompact($tableNameOrRegionName);
  $self->recv_majorCompact();
}

sub send_majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  $self->{output}->writeMessageBegin('majorCompact', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_majorCompact_args();
  $args->{tableNameOrRegionName} = $tableNameOrRegionName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_majorCompact{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_majorCompact_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub getTableNames{
  my $self = shift;

    $self->send_getTableNames();
  return $self->recv_getTableNames();
}

sub send_getTableNames{
  my $self = shift;

  $self->{output}->writeMessageBegin('getTableNames', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getTableNames_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableNames{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getTableNames_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getTableNames failed: unknown result";
}
sub getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

    $self->send_getColumnDescriptors($tableName);
  return $self->recv_getColumnDescriptors();
}

sub send_getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('getColumnDescriptors', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getColumnDescriptors_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getColumnDescriptors{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getColumnDescriptors_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getColumnDescriptors failed: unknown result";
}
sub getTableRegions{
  my $self = shift;
  my $tableName = shift;

    $self->send_getTableRegions($tableName);
  return $self->recv_getTableRegions();
}

sub send_getTableRegions{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('getTableRegions', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getTableRegions_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableRegions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getTableRegions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getTableRegions failed: unknown result";
}
sub createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

    $self->send_createTable($tableName, $columnFamilies);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

  $self->{output}->writeMessageBegin('createTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_createTable_args();
  $args->{tableName} = $tableName;
  $args->{columnFamilies} = $columnFamilies;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_createTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  if (defined $result->{exist}) {
    die $result->{exist};
  }
  return;
}
sub deleteTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_deleteTable($tableName);
  $self->recv_deleteTable();
}

sub send_deleteTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('deleteTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

    $self->send_get($tableName, $row, $column, $attributes);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('get', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_get_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "get failed: unknown result";
}
sub getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

    $self->send_getVer($tableName, $row, $column, $numVersions, $attributes);
  return $self->recv_getVer();
}

sub send_getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getVer', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getVer_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{numVersions} = $numVersions;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getVer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getVer_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getVer failed: unknown result";
}
sub getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

    $self->send_getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
  return $self->recv_getVerTs();
}

sub send_getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getVerTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getVerTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{timestamp} = $timestamp;
  $args->{numVersions} = $numVersions;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getVerTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getVerTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getVerTs failed: unknown result";
}
sub getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

    $self->send_getRow($tableName, $row, $attributes);
  return $self->recv_getRow();
}

sub send_getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRow', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRow_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRow failed: unknown result";
}
sub getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_getRowWithColumns($tableName, $row, $columns, $attributes);
  return $self->recv_getRowWithColumns();
}

sub send_getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowWithColumns', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowWithColumns_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowWithColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowWithColumns_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowWithColumns failed: unknown result";
}
sub getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowTs($tableName, $row, $timestamp, $attributes);
  return $self->recv_getRowTs();
}

sub send_getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowTs failed: unknown result";
}
sub getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
  return $self->recv_getRowWithColumnsTs();
}

sub send_getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowWithColumnsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowWithColumnsTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowWithColumnsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowWithColumnsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowWithColumnsTs failed: unknown result";
}
sub getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

    $self->send_getRows($tableName, $rows, $attributes);
  return $self->recv_getRows();
}

sub send_getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRows', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRows_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRows failed: unknown result";
}
sub getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_getRowsWithColumns($tableName, $rows, $columns, $attributes);
  return $self->recv_getRowsWithColumns();
}

sub send_getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsWithColumns', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowsWithColumns_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsWithColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowsWithColumns_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsWithColumns failed: unknown result";
}
sub getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowsTs($tableName, $rows, $timestamp, $attributes);
  return $self->recv_getRowsTs();
}

sub send_getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowsTs_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsTs failed: unknown result";
}
sub getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
  return $self->recv_getRowsWithColumnsTs();
}

sub send_getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsWithColumnsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowsWithColumnsTs_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsWithColumnsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowsWithColumnsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsWithColumnsTs failed: unknown result";
}
sub mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

    $self->send_mutateRow($tableName, $row, $mutations, $attributes);
  $self->recv_mutateRow();
}

sub send_mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRow', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRow_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{mutations} = $mutations;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
  $self->recv_mutateRowTs();
}

sub send_mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRowTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRowTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{mutations} = $mutations;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRowTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

    $self->send_mutateRows($tableName, $rowBatches, $attributes);
  $self->recv_mutateRows();
}

sub send_mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRows', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRows_args();
  $args->{tableName} = $tableName;
  $args->{rowBatches} = $rowBatches;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
  $self->recv_mutateRowsTs();
}

sub send_mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRowsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRowsTs_args();
  $args->{tableName} = $tableName;
  $args->{rowBatches} = $rowBatches;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRowsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRowsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

    $self->send_atomicIncrement($tableName, $row, $column, $value);
  return $self->recv_atomicIncrement();
}

sub send_atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('atomicIncrement', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_atomicIncrement_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_atomicIncrement{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_atomicIncrement_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "atomicIncrement failed: unknown result";
}
sub deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

    $self->send_deleteAll($tableName, $row, $column, $attributes);
  $self->recv_deleteAll();
}

sub send_deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAll', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAll_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAll{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAll_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
  $self->recv_deleteAllTs();
}

sub send_deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAllTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAllTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

    $self->send_deleteAllRow($tableName, $row, $attributes);
  $self->recv_deleteAllRow();
}

sub send_deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllRow', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAllRow_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAllRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub increment{
  my $self = shift;
  my $increment = shift;

    $self->send_increment($increment);
  $self->recv_increment();
}

sub send_increment{
  my $self = shift;
  my $increment = shift;

  $self->{output}->writeMessageBegin('increment', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_increment_args();
  $args->{increment} = $increment;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_increment{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_increment_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub incrementRows{
  my $self = shift;
  my $increments = shift;

    $self->send_incrementRows($increments);
  $self->recv_incrementRows();
}

sub send_incrementRows{
  my $self = shift;
  my $increments = shift;

  $self->{output}->writeMessageBegin('incrementRows', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_incrementRows_args();
  $args->{increments} = $increments;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_incrementRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_incrementRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_deleteAllRowTs($tableName, $row, $timestamp, $attributes);
  $self->recv_deleteAllRowTs();
}

sub send_deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllRowTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAllRowTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAllRowTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithScan($tableName, $scan, $attributes);
  return $self->recv_scannerOpenWithScan();
}

sub send_scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithScan', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithScan_args();
  $args->{tableName} = $tableName;
  $args->{scan} = $scan;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithScan{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithScan_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithScan failed: unknown result";
}
sub scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpen($tableName, $startRow, $columns, $attributes);
  return $self->recv_scannerOpen();
}

sub send_scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpen', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpen_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpen{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpen_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpen failed: unknown result";
}
sub scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
  return $self->recv_scannerOpenWithStop();
}

sub send_scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithStop', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithStop_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{stopRow} = $stopRow;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithStop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithStop_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithStop failed: unknown result";
}
sub scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
  return $self->recv_scannerOpenWithPrefix();
}

sub send_scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithPrefix', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithPrefix_args();
  $args->{tableName} = $tableName;
  $args->{startAndPrefix} = $startAndPrefix;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithPrefix{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithPrefix_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithPrefix failed: unknown result";
}
sub scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
  return $self->recv_scannerOpenTs();
}

sub send_scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenTs_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenTs failed: unknown result";
}
sub scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
  return $self->recv_scannerOpenWithStopTs();
}

sub send_scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithStopTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithStopTs_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{stopRow} = $stopRow;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithStopTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithStopTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithStopTs failed: unknown result";
}
sub scannerGet{
  my $self = shift;
  my $id = shift;

    $self->send_scannerGet($id);
  return $self->recv_scannerGet();
}

sub send_scannerGet{
  my $self = shift;
  my $id = shift;

  $self->{output}->writeMessageBegin('scannerGet', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerGet_args();
  $args->{id} = $id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerGet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerGet_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "scannerGet failed: unknown result";
}
sub scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

    $self->send_scannerGetList($id, $nbRows);
  return $self->recv_scannerGetList();
}

sub send_scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

  $self->{output}->writeMessageBegin('scannerGetList', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerGetList_args();
  $args->{id} = $id;
  $args->{nbRows} = $nbRows;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerGetList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerGetList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "scannerGetList failed: unknown result";
}
sub scannerClose{
  my $self = shift;
  my $id = shift;

    $self->send_scannerClose($id);
  $self->recv_scannerClose();
}

sub send_scannerClose{
  my $self = shift;
  my $id = shift;

  $self->{output}->writeMessageBegin('scannerClose', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerClose_args();
  $args->{id} = $id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerClose{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerClose_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub getRowOrBefore{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $family = shift;

    $self->send_getRowOrBefore($tableName, $row, $family);
  return $self->recv_getRowOrBefore();
}

sub send_getRowOrBefore{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $family = shift;

  $self->{output}->writeMessageBegin('getRowOrBefore', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowOrBefore_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{family} = $family;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowOrBefore{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowOrBefore_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowOrBefore failed: unknown result";
}
sub getRegionInfo{
  my $self = shift;
  my $row = shift;

    $self->send_getRegionInfo($row);
  return $self->recv_getRegionInfo();
}

sub send_getRegionInfo{
  my $self = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('getRegionInfo', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRegionInfo_args();
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRegionInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRegionInfo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRegionInfo failed: unknown result";
}
package Hbase::HbaseProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_enableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_enableTable_result();
    eval {
      $self->{handler}->enableTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('enableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_disableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_disableTable_result();
    eval {
      $self->{handler}->disableTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('disableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isTableEnabled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_isTableEnabled_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_isTableEnabled_result();
    eval {
      $result->{success} = $self->{handler}->isTableEnabled($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('isTableEnabled', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_compact {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_compact_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_compact_result();
    eval {
      $self->{handler}->compact($args->tableNameOrRegionName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('compact', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_majorCompact {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_majorCompact_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_majorCompact_result();
    eval {
      $self->{handler}->majorCompact($args->tableNameOrRegionName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('majorCompact', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableNames {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getTableNames_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getTableNames_result();
    eval {
      $result->{success} = $self->{handler}->getTableNames();
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getTableNames', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getColumnDescriptors {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getColumnDescriptors_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getColumnDescriptors_result();
    eval {
      $result->{success} = $self->{handler}->getColumnDescriptors($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getColumnDescriptors', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableRegions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getTableRegions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getTableRegions_result();
    eval {
      $result->{success} = $self->{handler}->getTableRegions($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getTableRegions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_createTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_createTable_result();
    eval {
      $self->{handler}->createTable($args->tableName, $args->columnFamilies);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::AlreadyExists') ){ 
      $result->{exist} = $@;
    }
    $output->writeMessageBegin('createTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteTable_result();
    eval {
      $self->{handler}->deleteTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->tableName, $args->row, $args->column, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('get', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getVer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getVer_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getVer_result();
    eval {
      $result->{success} = $self->{handler}->getVer($args->tableName, $args->row, $args->column, $args->numVersions, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getVer', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getVerTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getVerTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getVerTs_result();
    eval {
      $result->{success} = $self->{handler}->getVerTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->numVersions, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getVerTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRow_result();
    eval {
      $result->{success} = $self->{handler}->getRow($args->tableName, $args->row, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowWithColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowWithColumns_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowWithColumns_result();
    eval {
      $result->{success} = $self->{handler}->getRowWithColumns($args->tableName, $args->row, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowWithColumns', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowWithColumnsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowWithColumnsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowWithColumnsTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowWithColumnsTs($args->tableName, $args->row, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowWithColumnsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRows_result();
    eval {
      $result->{success} = $self->{handler}->getRows($args->tableName, $args->rows, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsWithColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowsWithColumns_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowsWithColumns_result();
    eval {
      $result->{success} = $self->{handler}->getRowsWithColumns($args->tableName, $args->rows, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowsWithColumns', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowsTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowsTs($args->tableName, $args->rows, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsWithColumnsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowsWithColumnsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowsWithColumnsTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowsWithColumnsTs($args->tableName, $args->rows, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowsWithColumnsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRow_result();
    eval {
      $self->{handler}->mutateRow($args->tableName, $args->row, $args->mutations, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRowTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRowTs_result();
    eval {
      $self->{handler}->mutateRowTs($args->tableName, $args->row, $args->mutations, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRowTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRows_result();
    eval {
      $self->{handler}->mutateRows($args->tableName, $args->rowBatches, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRowsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRowsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRowsTs_result();
    eval {
      $self->{handler}->mutateRowsTs($args->tableName, $args->rowBatches, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRowsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_atomicIncrement {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_atomicIncrement_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_atomicIncrement_result();
    eval {
      $result->{success} = $self->{handler}->atomicIncrement($args->tableName, $args->row, $args->column, $args->value);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('atomicIncrement', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAll {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAll_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAll_result();
    eval {
      $self->{handler}->deleteAll($args->tableName, $args->row, $args->column, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAll', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAllTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAllTs_result();
    eval {
      $self->{handler}->deleteAllTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAllTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAllRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAllRow_result();
    eval {
      $self->{handler}->deleteAllRow($args->tableName, $args->row, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAllRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_increment {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_increment_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_increment_result();
    eval {
      $self->{handler}->increment($args->increment);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('increment', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_incrementRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_incrementRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_incrementRows_result();
    eval {
      $self->{handler}->incrementRows($args->increments);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('incrementRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAllRowTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAllRowTs_result();
    eval {
      $self->{handler}->deleteAllRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAllRowTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithScan {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithScan_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithScan_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithScan($args->tableName, $args->scan, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithScan', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpen {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpen_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpen_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpen($args->tableName, $args->startRow, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpen', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithStop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithStop_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithStop_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithStop($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithStop', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithPrefix {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithPrefix_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithPrefix_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithPrefix($args->tableName, $args->startAndPrefix, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithPrefix', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenTs_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenTs($args->tableName, $args->startRow, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithStopTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithStopTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithStopTs_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithStopTs($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithStopTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerGet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerGet_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerGet_result();
    eval {
      $result->{success} = $self->{handler}->scannerGet($args->id);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('scannerGet', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerGetList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerGetList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerGetList_result();
    eval {
      $result->{success} = $self->{handler}->scannerGetList($args->id, $args->nbRows);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('scannerGetList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerClose {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerClose_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerClose_result();
    eval {
      $self->{handler}->scannerClose($args->id);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('scannerClose', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowOrBefore {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowOrBefore_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowOrBefore_result();
    eval {
      $result->{success} = $self->{handler}->getRowOrBefore($args->tableName, $args->row, $args->family);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowOrBefore', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRegionInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRegionInfo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRegionInfo_result();
    eval {
      $result->{success} = $self->{handler}->getRegionInfo($args->row);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRegionInfo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
